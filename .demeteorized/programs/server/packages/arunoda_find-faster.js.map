{"version":3,"file":"/packages/arunoda:find-faster.js","sources":["arunoda:find-faster/lib/server.js","arunoda:find-faster/lib/override.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,gB;;AAEA,mF;AACA,sC;AACA,6B;;AAEA,oD;AACA,4E;AACA,0B;AACA,gD;AACA,8C;;AAEA,oC;AACA,2D;AACA,8B;;AAEA,mC;AACA,kB;AACA,mD;AACA,gD;AACA,qF;;AAEA,qB;AACA,C;;AAEA,6D;AACA,c;AACA,a;;AAEA,qD;AACA,2B;AACA,iB;AACA,6E;AACA,sE;AACA,W;AACA,oE;AACA,oB;AACA,mB;AACA,sE;AACA,+D;AACA,qB;AACA,O;AACA,oB;AACA,4D;AACA,4E;AACA,oB;AACA,0E;AACA,uB;AACA,0C;AACA,oB;AACA,W;AACA,qE;AACA,4D;AACA,oB;AACA,mB;AACA,sE;AACA,+D;AACA,qB;AACA,O;AACA,+D;;AAEA,qB;AACA,C;;AAEA,2B;AACA,kE;AACA,kC;AACA,4C;AACA,sC;AACA,E;;AAEA,uC;AACA,4C;AACA,kC;AACA,0D;AACA,iD;AACA,mD;AACA,gE;AACA,0B;AACA,O;AACA,I;AACA,qE;AACA,kB;;AAEA,uB;AACA,G;AACA,C;;AAEA,mC;AACA,yF;;AAEA,qD;AACA,6E;AACA,qD;AACA,mE;AACA,gD;AACA,+E;AACA,4F;;AAEA,4C;AACA,G;AACA,E;AACA,4D;AACA,6C;AACA,kE;AACA,qD;AACA,yD;;AAEA,sB;AACA,wC;AACA,iB;AACA,yD;AACA,G;AACA,E;AACA,qE;AACA,uE;AACA,mC;AACA,gB;AACA,U;AACA,mD;AACA,qE;AACA,G;AACA,C;;AAEA,oE;AACA,gB;AACA,yC;AACA,mB;AACA,qC;AACA,Y;AACA,qD;AACA,+B;AACA,+C;AACA,uB;AACA,S;AACA,K;AACA,K;AACA,c;AACA,C;;AAEA,kC;AACA,sD;AACA,0D;AACA,4C;AACA,yC;AACA,U;AACA,0C;AACA,G;AACA,C;;AAEA,kD;AACA,oF;AACA,0E;;AAEA,wB;AACA,2B;AACA,8C;AACA,qB;AACA,U;AACA,+C;AACA,+C;AACA,wD;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;ACnKA,+C;AACA,kD;;AAEA,O;AACA,sC;AACA,gC;AACA,0C;AACA,mC;AACA,U;AACA,gD;AACA,G;AACA,E;;AAEA,S;AACA,0C;AACA,mD;AACA,0C;AACA,uC;AACA,sB;;AAEA,uC;AACA,iD;AACA,O;AACA,U;AACA,kD;AACA,G;AACA,E;;AAEA,M;AACA,kC;AACA,+C;AACA,0C;AACA,oB;AACA,sB;;AAEA,uC;AACA,uC;AACA,8D;AACA,O;AACA,kB;AACA,U;AACA,qD;AACA,G;AACA,E;;AAEA,8B;AACA,0D;AACA,kC;AACA,wC;AACA,sC;;AAEA,4B;AACA,sC;AACA,E;;AAEA,6D;AACA,kC;AACA,wC;AACA,sC;;AAEA,4B;AACA,oD;AACA,kC;AACA,0C;AACA,yC;AACA,E","sourcesContent":["FindFaster = {};\n\nFindFaster._dummyColl = new Meteor.Collection('__dummy_collection_' + Random.id());\nFindFaster._lastTimeObserverUsed = {};\nFindFaster._keepHandles = {};\n\nFindFaster._getCursorProto = _.once(getCursorProto);\nFindFaster._getOplogObserveDriverClass = _.once(getOplogObserveDriverClass);\nFindFaster._fetch = fetch;\nFindFaster._canUseFindFaster = canUseFindFaster;\nFindFaster._getExpectedDocs = getExpectedDocs;\n\nFindFaster.defaultExpectedDocs  = 1;\nFindFaster.expectedDocs = new Meteor.EnvironmentVariable();\nFindFaster.timeout = 5 * 1000;\n\nfunction canUseFindFaster(cursor) {\n  var condition = \n    cursor._cursorDescription.options.findFaster &&\n    FindFaster._getOplogObserveDriverClass() && \n    canUseOplog(cursor._cursorDescription, FindFaster._getOplogObserveDriverClass());\n\n  return !!condition;\n}\n\nfunction canUseOplog(cursorDescription, OplogObserveDriver) {\n  var matcher;\n  var sorter;\n\n  // stolen and modified from Meteor's mongo-livedata\n  var canUseOplog = _.all([\n    function () {\n      // We need to be able to compile the selector. Fall back to polling for\n      // some newfangled $selector that minimongo doesn't support yet.\n      try {\n        matcher = new Minimongo.Matcher(cursorDescription.selector);\n        return true;\n      } catch (e) {\n        // XXX make all compilation errors MinimongoError or something\n        //     so that this doesn't ignore unrelated exceptions\n        return false;\n      }\n    }, function () {\n      // ... and the selector itself needs to support oplog.\n      return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n    }, function () {\n      // And we need to be able to compile the sort, if any.  eg, can't be\n      // {$natural: 1}.\n      if (!cursorDescription.options.sort)\n        return true;\n      try {\n        sorter = new Minimongo.Sorter(cursorDescription.options.sort,\n                                      { matcher: matcher });\n        return true;\n      } catch (e) {\n        // XXX make all compilation errors MinimongoError or something\n        //     so that this doesn't ignore unrelated exceptions\n        return false;\n      }\n    }], function (f) { return f(); });  // invoke each function\n\n  return canUseOplog;\n}\n\nfunction getCursorProto() {\n  // allow Meteor to connect to Mongo and initialze the connection\n  FindFaster._dummyColl.findOne();\n  var cursor = FindFaster._dummyColl.find();\n  return cursor.constructor.prototype;\n};\n\nfunction getOplogObserveDriverClass() {\n  var cursor = FindFaster._dummyColl.find();\n  if(cursor._mongo._oplogHandle) {\n    // we need to waitUntil, oplog driver gets initialized\n    // otherwise we counldn't get the OplogDriver\n    cursor._mongo._oplogHandle.waitUntilCaughtUp();\n    var handle = FindFaster._dummyColl.find({}).observeChanges({\n      added: function() {}\n    });\n    \n    var driverClass = handle._multiplexer._observeDriver.constructor;\n    handle.stop();\n\n    return driverClass;\n  }\n}\n\nfunction fetch(cursor, dontClone) {\n  var observeKey = JSON.stringify(_.extend({ordered: false}, cursor._cursorDescription));\n\n  if(!FindFaster._lastTimeObserverUsed[observeKey]) {\n    // creating a new cursor with removing FindFaster option to avoid locking\n    // and using FindFaster inside the observeChanges\n    var cursorDescription = EJSON.clone(cursor._cursorDescription);\n    delete cursorDescription.options.findFaster;\n    var newCursor = new (cursor.constructor)(cursor._mongo, cursorDescription);\n    FindFaster._keepHandles[observeKey] = newCursor.observeChanges({added: function() {}}); \n\n    timeoutKeepObserver(cursor, observeKey);\n  }\n  \n  FindFaster._lastTimeObserverUsed[observeKey] = Date.now();\n  // since FindFaster is eventual consistancy\n  // asking expectedDocs values makes us to make FindFaster closer\n  // to strong consistancy for simple fetchs like _id\n  var expectedDocs = FindFaster._getExpectedDocs(cursor);\n\n  //transform function\n  var transform = cursor.getTransform();\n  if(transform) {\n    transform = LocalCollection.wrapTransform(transform);\n  }\n  \n  var multiplexer = FindFaster._keepHandles[observeKey]._multiplexer;\n  var docs = getDocsFromMultiflexer(multiplexer, dontClone, transform);\n  if(docs.length >= expectedDocs) {\n    return docs;\n  } else {\n    cursor._mongo._oplogHandle.waitUntilCaughtUp();\n    return getDocsFromMultiflexer(multiplexer, dontClone, transform);\n  }\n}\n\nfunction getDocsFromMultiflexer(multiplexer, dontClone, transform) {\n  var docs = [];\n  multiplexer._queue.runTask(function() {\n    if(dontClone) {\n      docs = multiplexer._cache.docs;\n    } else {\n      multiplexer._cache.docs.forEach(function(doc) {\n        doc = EJSON.clone(doc);\n        doc = (transform)? transform(doc): doc;\n        docs.push(doc);\n      });\n    }\n  });\n  return docs;\n}\n\nfunction getExpectedDocs(cursor) {\n  if(cursor._cursorDescription.options.expectedDocs) {\n    return cursor._cursorDescription.options.expectedDocs;\n  } else if(FindFaster.expectedDocs.get()) {\n    return FindFaster.expectedDocs.get();\n  } else {\n    return FindFaster.defaultExpectedDocs;\n  }\n}\n\nfunction timeoutKeepObserver(cursor, observeKey) {\n  var lastTimeObserved = FindFaster._lastTimeObserverUsed[observeKey] || Date.now();\n  var timeoutValue = (lastTimeObserved + FindFaster.timeout) - Date.now();\n\n  if(timeoutValue > 0) {\n    setTimeout(function() {\n      timeoutKeepObserver(cursor, observeKey);\n    }, timeoutValue);\n  } else {\n    FindFaster._keepHandles[observeKey].stop();\n    FindFaster._keepHandles[observeKey] = null;\n    FindFaster._lastTimeObserverUsed[observeKey] = null;\n  }\n}","var cursorProto = FindFaster._getCursorProto();\nvar collectionProto = Meteor.Collection.prototype;\n\n//fetch\nvar originalFetch = cursorProto.fetch;\ncursorProto.fetch = function() {\n  if(FindFaster._canUseFindFaster(this)) {\n    return FindFaster._fetch(this);\n  } else {\n    return originalFetch.apply(this, arguments);\n  }\n};\n\n//forEach\nvar originalForEach = cursorProto.forEach;\ncursorProto.forEach = function(callback, thisArg) {\n  if(FindFaster._canUseFindFaster(this)) {\n    var docs = FindFaster._fetch(this);\n    var cursor = this;\n\n    docs.forEach(function(doc, index) {\n      callback.call(thisArg, doc, index, cursor);\n    });\n  } else {\n    return originalForEach.apply(this, arguments);\n  }\n};\n\n// Map\nvar originalMap = cursorProto.map;\ncursorProto.map = function(callback, thisArg) {\n  if(FindFaster._canUseFindFaster(this)) {\n    var result = [];\n    var cursor = this;\n\n    var docs = FindFaster._fetch(this);\n    docs.forEach(function(doc, index) {\n      result.push(callback.call(thisArg, doc, index, cursor));\n    });\n    return result;\n  } else {\n    return originalMap.call(this, callback, thisArg);\n  }\n};\n\n// Extending Meteor.Collection\ncollectionProto.findFaster = function(selector, options) {\n  var args = _.toArray(arguments);\n  selector = this._getFindSelector(args)\n  options = this._getFindOptions(args)\n\n  options.findFaster = true;\n  return this.find(selector, options);\n};\n\ncollectionProto.findOneFaster = function(selector, options) {\n  var args = _.toArray(arguments);\n  selector = this._getFindSelector(args)\n  options = this._getFindOptions(args)\n\n  options.findFaster = true;\n  // this is need since, Meteor rejects to use oplog\n  // if there is no sort specifier\n  options.sort = options.sort || {_id: 1};\n  return this.findOne(selector, options);\n};\n"]}